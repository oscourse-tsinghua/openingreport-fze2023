@article{cg_rtl,
  title   = {基于RTL的函数调用图生成工具CG-RTL},
  author  = {孙卫真 and 杜香燕 and 向勇 and 汤卫东 and 侯鸿儒},
  journal = {小型微型计算机系统},
  volume  = {35},
  number  = {3},
  pages   = {5},
  year    = {2014}
}

@article{dcg_rtl,
author={向勇 and 汤卫东 and 杜香燕 and 孙卫真},
title={ 基于内核跟踪的动态函数调用图生成方法 },
organization={清华大学 and 首都师范大学},
journal={计算机应用研究},
year={2015},
volume={32},
number={4},
pages={1095-1099},
month={1},
}

@article{dbcg_rtl,
author={贾荻 and 向勇 and 孙卫真 and 曹睿东},
title={ 基于数据库的在线函数调用图工具 },
organization={首都师范大学 and 清华大学},
journal={小型微型计算机系统},
year={2016},
volume={37},
number={3},
pages={422-427},
month={1},
}

@article{Prazi,
  author     = {Hejderup, Joseph and Beller, Moritz and Triantafyllou, Konstantinos and Gousios, Georgios},
  title      = {Pr\"{a}zi: from package-based to call-based dependency networks},
  year       = {2022},
  issue_date = {Sep 2022},
  publisher  = {Kluwer Academic Publishers},
  address    = {USA},
  volume     = {27},
  number     = {5},
  issn       = {1382-3256},
  url        = {https://doi.org/10.1007/s10664-021-10071-9},
  doi        = {10.1007/s10664-021-10071-9},
  abstract   = {Modern programming languages such as Java, JavaScript, and Rust encourage software reuse by hosting diverse and fast-growing repositories of highly interdependent packages (i.e., reusable libraries) for their users. The standard way to study the interdependence between software packages is to infer a package dependency network by parsing manifest data. Such networks help answer questions such as “How many packages have dependencies to packages with known security issues?” or “What are the most used packages?”. However, an overlooked aspect in existing studies is that manifest-inferred relationships do not necessarily examine the actual usage of these dependencies in source code. To better model dependencies between packages, we developed Pr\"{a}zi, an approach combining manifests and call graphs of packages. Pr\"{a}zi constructs a dependency network at the more fine-grained function-level, instead of at the manifest level. This paper discusses a prototypical Pr\"{a}zi implementation for the popular system programming language Rust. We use Pr\"{a}zi to characterize Rust’s package repository, Crates.io, at the function level and perform a comparative study with metadata-based networks. Our results show that metadata-based networks generalize how packages use their dependencies. Using Pr\"{a}zi, we find packages call only 40\% of their resolved dependencies, and that manual analysis of 34 cases reveals that not all packages use a dependency the same way. We argue that researchers and practitioners interested in understanding how developers or programs use dependencies should account for its context—not the sum of all resolved dependencies.},
  journal    = {Empirical Softw. Engg.},
  month      = {sep},
  numpages   = {42},
  keywords   = {Package repository, Dependency network, Package manager, Software ecosystem, Network analysis, Call graphs}
}

@inproceedings{MirChecker,
  author    = {Li, Zhuohua and Wang, Jincheng and Sun, Mingshen and Lui, John C.S.},
  title     = {MirChecker: Detecting Bugs in Rust Programs via Static Analysis},
  year      = {2021},
  isbn      = {9781450384544},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3460120.3484541},
  doi       = {10.1145/3460120.3484541},
  abstract  = {Safe system programming is often a crucial requirement due to its critical role in system software engineering. Conventional low-level programming languages such as C and assembly are efficient, but their inherent unsafe nature makes it undesirable for security-critical scenarios. Recently, Rust has become a promising alternative for safe system-level programming. While giving programmers fine-grained hardware control, its strong type system enforces many security properties including memory safety. However, Rust's security guarantee is not a silver bullet. Runtime crashes and memory-safety errors still harass Rust developers, causing damaging exploitable vulnerabilities, as reported by numerous studies.In this paper, we present and evaluate MirChecker, a fully automated bug detection framework for Rust programs by performing static analysis on Rust's Mid-level Intermediate Representation (MIR). Based on the observation of existing bugs found in Rust codebases, our approach keeps track of both numerical and symbolic information, detects potential runtime crashes and memory-safety errors by using constraint solving techniques, and outputs informative diagnostics to users. We evaluate MirChecker on both buggy code snippets extracted from existing Common Vulnerabilities and Exposures (CVE) and real-world Rust codebases. Our experiments show that MirChecker can detect all the issues in our code snippets, and is capable of performing bug finding in real-world scenarios, where it detected a total of 33 previously unknown bugs including 16 memory-safety issues from 12 Rust packages (crates) with an acceptable false-positive rate.},
  booktitle = {Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {2183–2196},
  numpages  = {14},
  keywords  = {static analysis, rust, abstract interpretation},
  location  = {Virtual Event, Republic of Korea},
  series    = {CCS '21}
}

@inproceedings{Kani,
  author    = {VanHattum, Alexa and Schwartz-Narbonne, Daniel and Chong, Nathan and Sampson, Adrian},
  title     = {Verifying dynamic trait objects in rust},
  year      = {2022},
  isbn      = {9781450392266},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3510457.3513031},
  doi       = {10.1145/3510457.3513031},
  abstract  = {Rust has risen in prominence as a systems programming language in large part due to its focus on reliability. The language's advanced type system and borrow checker eliminate certain classes of memory safety violations. But for critical pieces of code, teams need assurance beyond what the type checker alone can provide. Verification tools for Rust can check other properties, from memory faults in unsafe Rust code to user-defined correctness assertions. This paper particularly focuses on the challenges in reasoning about Rust's dynamic trait objects, a feature that provides dynamic dispatch for function abstractions. While the explicit dyn keyword that denotes dynamic dispatch is used in 37\% of the 500 most-downloaded Rust libraries (crates), dynamic dispatch is implicitly linked into 70\%. To our knowledge, our open-source Kani Rust Verifier is the first symbolic modeling checking tool for Rust that can verify correctness while supporting the breadth of dynamic trait objects, including dynamically dispatched closures. We show how our system uses semantic trait information from Rust's Mid-level Intermediate Representation (an advantage over targeting a language-agnostic level such as LLVM) to improve verification performance by 5\%--15\texttimes{} for examples from open-source virtualization software. Finally, we share an open-source suite of verification test cases for dynamic trait objects.},
  booktitle = {Proceedings of the 44th International Conference on Software Engineering: Software Engineering in Practice},
  pages     = {321–330},
  numpages  = {10},
  keywords  = {dynamic dispatch, model checking, rust, verification},
  location  = {Pittsburgh, Pennsylvania},
  series    = {ICSE-SEIP '22}
}