# openingreport-fze2023

存储傅泽同学的研究生论文的开题报告。

# 迷茫中的调研结果

## 把大象装进冰箱里分几步？

目前按照笔者理解，“将Substrate移植到rCore中”大概需要这么几步：

### 1. 对Substrate尽可能做简化

详见下文中的死代码移除意义 & 死代码移除技术现状。

### 2. 将不能在no-std环境中运行的crate尽可能替换掉

### 3. 为剩下的不支持no-std环境的crate做适配

### 4. 逐步移植、验证

## 死代码移除的意义何在？

[A Multi-Study Investigation into Dead Code | IEEE Journals & Magazine | IEEE Xplore](https://ieeexplore.ieee.org/abstract/document/8370748)从多个角度论述了死代码对软件项目的危害性。主要可以归结为以下几点：

- **令代码更难理解**: 开发者更难理解代码的结构和用意。对于经验较浅的新开发人员，他们可能会误以为死代码是有用的，从而轻则花费不必要的时间弄懂死代码、重则任其累积或对其作出错误的修改，令代码库的质量越来越差。
- **令代码更难维护**: 让维护工作变得更加复杂，在日常维护或升级迭代时影响开发人员的工作效率、在降低代码质量的同时可能还会引入新的缺陷甚至错误。
- **徒增开发工时**: 开发者花费无用的时间维护死代码或对其进行debug，而这部分工作对项目并无任何帮助。
- **拖慢运行效率**: 虽非总是如此，但死代码有可能拖慢运行效率或徒增内存占用。
- **拉低代码质量**: 死代码越多，可以认为团队的专业性越低，开发标准越宽松。

## 死代码移除技术现状

目前在模块层级的代码裁剪上做得比较好的是JavaScript的Tree Shaking技术。这种技术概述大致如下：

- 这东西是根据ES6模块中的`import`和`export`工作的。因此不能用于`CommonJS`（因为`CommonJS`可能会使用require，从而令引入分析变得复杂）。
- 这项技术是在编译时自动进行的，对源代码没有修改，也没有报告警告。

Rust在移除多余代码的方面也有一些工作。它也会利用`use`和`mod`来进行冗余代码裁剪。和Tree Shaking一样的是，这些过程对开发者都是透明的，且不对源代码做修改/警告。

[A Multi-Study Investigation into Dead Code | IEEE Journals & Magazine | IEEE Xplore](https://ieeexplore.ieee.org/abstract/document/8370748)中展示了几种已有的死代码移除技术。与上文中提及的Tree Shaking不同，以下技术的目标都是去更改源代码文件，而非在编译时执行对开发者透明的优化操作：

- C++数据模型方法（接近当前研究方案的方法）
  - 针对所有C/C++实体（变量、函数、类型等统称为实体）进行裁剪
  - 裁剪依据源于两个集合：$S$集合（存储程序中所有实体）和$R(r)$（从实体$r$​​可达的全部实体）
  - 生成这俩集合的算法引用了非常远古的文献，该模型方法并未对这些算法进行详细说明
- PHP的Web系统动态方法
  - 针对PHP文件进行裁剪
  - 在一段时间内观测PHP项目的文件的使用情况，若某个文件一直都没被用到，那么认为它内部的代码全是死代码
- 动态静态结合的JSNOSE方法
  - 探测JavaScript项目的代码异味，其中探测死代码时是针对语句进行探测的
  - 给语句执行的次数进行计数，从而得知该语句是否可达
- 用于Java的静态DUM方法（接近当前研究方案的方法）
  - 首先对项目中所有的方法，根据其调用关系画一张有向图
  - 然后从代表入口函数的节点开始遍历，将可达的节点标记为活节点，剩下的一律标记为死节点
  - 作者团队依据此方法，为Eclipse开发了DUM-Tool插件

值得注意的是，笔者动用了谷歌、谷歌学术、Connected Papers等搜索途径，均未能发现有人在rust上做过类似于以上任意一种从源代码中移除死代码的尝试，只发现了一些有关rust上的Tree shaking的提问，和摸棱两可、缺少参考价值的回答。因此，笔者认为，rust源代码层级的死代码移除工作目前尚未有人涉足。
